package main

import (
	"compress/gzip"
	"encoding/json"
	"flag"
	"fmt"
	"net/http"
	"os"
	"path/filepath"
)

const (
	DataSource = "https://api.github.com/repos/countries/countries-data-json/contents/data/countries"
	Testdata   = "testdata/countries.json.gz"
	Datafile   = "countries.data.go"
)

// CLI Flags
var (
	noDownload bool
	noWrite    bool
)

func main() {
	// Step 1: Parse command line flags
	flag.BoolVar(&noDownload, "no-download", false, "Skip downloading country data")
	flag.BoolVar(&noWrite, "no-write", false, "Skip writing generated code")
	flag.Parse()

	// Step 2: Download the latest country data from the GitHub repository
	err := downloadData()
	handleError(err)

	// Write the data from testdata/countries.json to countries.go
	f, err := os.Create("countries.go")
	handleError(err)
	defer f.Close()

	// Write the preamble for the generated file
	_, err = f.WriteString("// Code generated by go generate; DO NOT EDIT.\n\n")
	handleError(err)

	// Guess the package name based on the current directory
	content := guessPackage()
	_, err = f.WriteString(content + "\n\n")
	handleError(err)

	os.Remove("countries.go")
}

func guessPackage() string {
	wd, err := os.Getwd()
	handleError(err)

	return fmt.Sprintf("package %s\n", filepath.Base(wd))
}

func handleError(err error) {
	if err != nil {
		fmt.Fprintf(os.Stderr, "countries generation failed: %s\n", err)
		os.Exit(1)
	}
}

//===========================================================================
// GitHub Interactions
//===========================================================================

type GitHubItem struct {
	Name string `json:"name"`
	Path string `json:"path"`
	Type string `json:"type"`
	Size int    `json:"size"`
	URL  string `json:"download_url"`
	SHA  string `json:"sha"`
}

type GitHubItems []GitHubItem

type GitHubCountry map[string]json.RawMessage

func downloadData() (err error) {
	if noDownload {
		return nil
	}

	var items GitHubItems
	if items, err = listRepoCountries(); err != nil {
		return err
	}

	data := make([]json.RawMessage, 0, len(items))
	for _, item := range items {
		var country json.RawMessage
		if country, err = fetchCountryData(item); err != nil {
			return err
		}
		data = append(data, country)
	}

	var f *os.File
	if f, err = os.Create(Testdata); err != nil {
		return fmt.Errorf("failed to create testdata file: %w", err)
	}
	defer f.Close()

	// Compress and write the JSON data to the testdata file
	gz := gzip.NewWriter(f)
	defer gz.Close()

	// Write the data to the file
	if err = json.NewEncoder(gz).Encode(data); err != nil {
		return fmt.Errorf("failed to write data to testdata file: %w", err)
	}

	return nil
}

func listRepoCountries() (out GitHubItems, err error) {
	var rep *http.Response
	if rep, err = http.Get(DataSource); err != nil {
		return nil, err
	}
	defer rep.Body.Close()

	if rep.StatusCode != http.StatusOK {
		return nil, fmt.Errorf("failed to fetch GitHub repository: %s", rep.Status)
	}

	out = make(GitHubItems, 0)
	if err = json.NewDecoder(rep.Body).Decode(&out); err != nil {
		return nil, fmt.Errorf("failed to decode GitHub response: %w", err)
	}

	return out, nil
}

func fetchCountryData(item GitHubItem) (_ json.RawMessage, err error) {
	var rep *http.Response
	if rep, err = http.Get(item.URL); err != nil {
		return nil, fmt.Errorf("failed to fetch country data from %s: %w", item.URL, err)
	}
	defer rep.Body.Close()

	if rep.StatusCode != http.StatusOK {
		return nil, fmt.Errorf("failed to fetch country data: %s", rep.Status)
	}

	country := make(GitHubCountry)
	if err = json.NewDecoder(rep.Body).Decode(&country); err != nil {
		return nil, fmt.Errorf("failed to decode country data: %w", err)
	}

	if len(country) != 1 {
		return nil, fmt.Errorf("expected exactly one country in data, got %d", len(country))
	}

	for _, data := range country {
		return data, nil
	}

	return nil, fmt.Errorf("no country data found in response")
}
