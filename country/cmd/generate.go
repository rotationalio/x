package main

import (
	"compress/gzip"
	"encoding/json"
	"flag"
	"fmt"
	"io"
	"net/http"
	"os"
	"path/filepath"
	"sync"
	"text/template"

	"go.rtnl.ai/x/country"
)

const (
	DataSource = "https://api.github.com/repos/countries/countries-data-json/contents/data/countries"
	Testdata   = "testdata/countries.json.gz"
	Datafile   = "countries.data.go"
)

// CLI Flags
var (
	noDownload bool
	noWrite    bool
)

func main() {
	// Step 1: Parse command line flags
	flag.BoolVar(&noDownload, "no-download", false, "Skip downloading country data")
	flag.BoolVar(&noWrite, "no-write", false, "Skip writing generated code")
	flag.Parse()

	// Step 2: Download the latest country data from the GitHub repository
	err := downloadData()
	handleError(err)

	// Step 3: Write the data from testdata/countries.json to countries.data.go
	err = writeCountriesData()
	handleError(err)
}

func handleError(err error) {
	if err != nil {
		fmt.Fprintf(os.Stderr, "countries generation failed: %s\n", err)
		os.Exit(1)
	}
}

//===========================================================================
// Code Generation
//===========================================================================

func writeCountriesData() (err error) {
	if noWrite {
		return nil
	}

	var countries []*country.Country
	if countries, err = readCountriesData(); err != nil {
		return fmt.Errorf("failed to read countries data: %w", err)
	}

	var f *os.File
	if f, err = os.Create(Datafile); err != nil {
		return fmt.Errorf("could not create %s: %w", Datafile, err)
	}
	defer f.Close()

	// Write the preamble for the generated file
	if _, err = f.WriteString("// Code generated by go generate; DO NOT EDIT.\n"); err != nil {
		return fmt.Errorf("failed to write preamble to %s: %w", Datafile, err)
	}

	// Guess the package name based on the current directory
	content := guessPackage()
	if _, err = f.WriteString(content + "\n\n"); err != nil {
		return fmt.Errorf("failed to write package declaration to %s: %w", Datafile, err)
	}

	// Open country data variable block
	if _, err = f.WriteString("// In memory country database\nvar (\n"); err != nil {
		return fmt.Errorf("failed to write opening var block to %s: %w", Datafile, err)
	}

	// Write each country data structure
	for _, country := range countries {
		if err = writeCountryData(f, country); err != nil {
			return fmt.Errorf("failed to write country data for %s: %w", country.Alpha2, err)
		}
	}

	// Close the variable block
	if _, err = f.WriteString(")\n\n"); err != nil {
		return fmt.Errorf("failed to write closing var block to %s: %w", Datafile, err)
	}

	// Write the lookup table for Alpha2 codes
	if err = writeAlpha2Lookup(f, countries); err != nil {
		return fmt.Errorf("failed to write Alpha2 lookup table: %w", err)
	}

	// Write the lookup table for Alpha3 codes
	if err = writeAlpha3Lookup(f, countries); err != nil {
		return fmt.Errorf("failed to write Alpha3 lookup table: %w", err)
	}

	return nil
}

func guessPackage() string {
	wd, err := os.Getwd()
	handleError(err)

	return fmt.Sprintf("package %s\n", filepath.Base(wd))
}

// Read Countries JSON data from testdata/countries.json.gz
func readCountriesData() (out []*country.Country, err error) {
	var f *os.File
	if f, err = os.Open(Testdata); err != nil {
		return nil, fmt.Errorf("could not open %s: %w", Testdata, err)
	}
	defer f.Close()

	gz, err := gzip.NewReader(f)
	if err != nil {
		return nil, fmt.Errorf("could not create gzip reader: %w", err)
	}
	defer gz.Close()

	if err = json.NewDecoder(gz).Decode(&out); err != nil {
		return nil, fmt.Errorf("could not decode JSON data: %w", err)
	}

	return out, nil
}

var countryStruct = `	{{ .Alpha2 }} = Country{
		Alpha2:          "{{ .Alpha2 }}",
		Alpha3:          "{{ .Alpha3 }}",
		ShortName:       "{{ .ShortName }}",
		LongName:        "{{ .LongName }}",
		CurrencyCode:    "{{ .CurrencyCode }}",
		DistanceUnit:    "{{ .DistanceUnit }}",
		UnofficialNames: {{ if .UnofficialNames }}{{ printf "%#v" .UnofficialNames }}{{ else }}nil{{ end }},
		Region:          "{{ .Region }}",
		Subregion:       "{{ .Subregion }}",
		Continent:       "{{ .Continent }}",
		Languages:       {{ if .Languages }}{{ printf "%#v" .Languages }}{{ else }}nil{{ end }},
	}

`

// Write a country data structure to the output file
func writeCountryData(w io.Writer, country *country.Country) (err error) {
	if err = compileTemplates(); err != nil {
		return fmt.Errorf("failed to compile templates: %w", err)
	}

	if err = countryStructTemplate.Execute(w, country); err != nil {
		return fmt.Errorf("could not render country struct template: %w", err)
	}

	return nil
}

var (
	compileTemplate       sync.Once
	compileTemplateErr    error
	countryStructTemplate *template.Template
)

func compileTemplates() (err error) {
	compileTemplate.Do(func() {
		countryStructTemplate, compileTemplateErr = template.New("country").Parse(countryStruct)
	})
	return compileTemplateErr
}

func writeAlpha2Lookup(w io.Writer, countries []*country.Country) (err error) {
	var table [26][26]string
	for _, country := range countries {
		row := country.Alpha2[0] - 'A'
		col := country.Alpha2[1] - 'A'
		table[row][col] = country.Alpha2
	}

	fmt.Fprintln(w, "// ISO-3166-1 Alpha2 Lookup Table")
	fmt.Fprintln(w, "var alpha2Lookup = [26][26]*Country{")
	for _, row := range table {
		fmt.Fprint(w, "\t{")
		for _, code := range row {
			if code == "" {
				fmt.Fprint(w, "nil, ")
			} else {
				fmt.Fprintf(w, "&%s, ", code)
			}
		}
		fmt.Fprintln(w, "},")
	}

	if _, err = fmt.Fprintln(w, "}"); err != nil {
		return fmt.Errorf("failed to write closing lookup table to %s: %w", Datafile, err)
	}
	return nil
}

func writeAlpha3Lookup(w io.Writer, countries []*country.Country) (err error) {
	var table [26][26][26]string
	for _, country := range countries {
		x := country.Alpha3[0] - 'A'
		y := country.Alpha3[1] - 'A'
		z := country.Alpha3[2] - 'A'
		table[x][y][z] = country.Alpha2
	}

	fmt.Fprintln(w, "// ISO-3166-1 Alpha3 Lookup Table")
	fmt.Fprintln(w, "var alpha3Lookup = [26][26][26]*Country{")
	for _, row := range table {
		fmt.Fprint(w, "\t{\n")
		for _, col := range row {
			fmt.Fprint(w, "\t\t{")
			for _, code := range col {
				if code == "" {
					fmt.Fprint(w, "nil, ")
				} else {
					fmt.Fprintf(w, "&%s, ", code)
				}
			}
			fmt.Fprint(w, "},\n")
		}
		fmt.Fprintln(w, "},")
	}

	if _, err = fmt.Fprintln(w, "}"); err != nil {
		return fmt.Errorf("failed to write closing lookup table to %s: %w", Datafile, err)
	}

	return nil
}

//===========================================================================
// GitHub Interactions
//===========================================================================

type GitHubItem struct {
	Name string `json:"name"`
	Path string `json:"path"`
	Type string `json:"type"`
	Size int    `json:"size"`
	URL  string `json:"download_url"`
	SHA  string `json:"sha"`
}

type GitHubItems []GitHubItem

type GitHubCountry map[string]json.RawMessage

func downloadData() (err error) {
	if noDownload {
		return nil
	}

	var items GitHubItems
	if items, err = listRepoCountries(); err != nil {
		return err
	}

	data := make([]json.RawMessage, 0, len(items))
	for _, item := range items {
		var country json.RawMessage
		if country, err = fetchCountryData(item); err != nil {
			return err
		}
		data = append(data, country)
	}

	var f *os.File
	if f, err = os.Create(Testdata); err != nil {
		return fmt.Errorf("failed to create testdata file: %w", err)
	}
	defer f.Close()

	// Compress and write the JSON data to the testdata file
	gz := gzip.NewWriter(f)
	defer gz.Close()

	// Write the data to the file
	if err = json.NewEncoder(gz).Encode(data); err != nil {
		return fmt.Errorf("failed to write data to testdata file: %w", err)
	}

	return nil
}

func listRepoCountries() (out GitHubItems, err error) {
	var rep *http.Response
	if rep, err = http.Get(DataSource); err != nil {
		return nil, err
	}
	defer rep.Body.Close()

	if rep.StatusCode != http.StatusOK {
		return nil, fmt.Errorf("failed to fetch GitHub repository: %s", rep.Status)
	}

	out = make(GitHubItems, 0)
	if err = json.NewDecoder(rep.Body).Decode(&out); err != nil {
		return nil, fmt.Errorf("failed to decode GitHub response: %w", err)
	}

	return out, nil
}

func fetchCountryData(item GitHubItem) (_ json.RawMessage, err error) {
	var rep *http.Response
	if rep, err = http.Get(item.URL); err != nil {
		return nil, fmt.Errorf("failed to fetch country data from %s: %w", item.URL, err)
	}
	defer rep.Body.Close()

	if rep.StatusCode != http.StatusOK {
		return nil, fmt.Errorf("failed to fetch country data: %s", rep.Status)
	}

	country := make(GitHubCountry)
	if err = json.NewDecoder(rep.Body).Decode(&country); err != nil {
		return nil, fmt.Errorf("failed to decode country data: %w", err)
	}

	if len(country) != 1 {
		return nil, fmt.Errorf("expected exactly one country in data, got %d", len(country))
	}

	for _, data := range country {
		return data, nil
	}

	return nil, fmt.Errorf("no country data found in response")
}
